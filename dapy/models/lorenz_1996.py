"""Model with one-dimensional spatial extent and chaotic non-linear dynamics.

Model originally proposed in:

> Lorenz, Edward (1996).
> Predictability – A problem partly solved.
> Seminar on Predictability, Vol. I, ECMWF.
"""

from typing import Optional, Union, Callable
import numpy as np
from dapy.models.base import DiagonalGaussianModel, IntegratorModel
from dapy.integrators.lorenz_1996 import Lorenz1996Integrator


class Lorenz1996Model(IntegratorModel, DiagonalGaussianModel):
    """Model on periodic one-dimensional spatial domain and chaotic non-linear dynamics.

    Model dynamics defined by the system of ODEs

        for j in range(dim_state):
            dx_dt[j] = (
                -x[(j-1) % dim_state] * (x[(j+1) % dim_state] - x[(j-2) % dim_state]) /
                (3 * delta) - x[j] + force)

    where `dim_state` is the number of grid points along the spatial direction. The
    `force` value represents a forcing constant and `delta` the grid spacing.

    An implicit mid-point method (with fixed point iteration to solve for the update) is
    used here to integrate the system from an initial state with a diagonal Gaussian
    distribution. The observations are assumed to be generated given states generated by
    integrating forward the dynamics by a fixed time interval (the product of the
    intergrator time step and the number of steps per update). Optionally as well as the
    numerical integration based state update, additive Gaussian noise may be also
    included in these fixed interval state updates to represent the accumulated model
    error. The observations are assumed to be computed as a possibly non-linear function
    of the state plus additive Gaussian observation noise.

    References:
        1. Lorenz, Edward (1996). Predictability – A problem partly solved.
           Seminar on Predictability, Vol. I, ECMWF.
    """

    def __init__(
        self,
        dim_state: int = 40,
        initial_state_mean: Union[float, np.ndarray] = 0.,
        initial_state_std: Union[float, np.ndarray] = 1.,
        state_noise_std: Optional[Union[float, np.ndarray]] = None,
        observation_function: Optional[Callable[[np.ndarray, int], np.ndarray]] = None,
        observation_noise_std: Union[float, np.ndarray] = 5.,
        delta: float = 1 / 3,
        force: float = 8.,
        time_step: float = 0.005,
        num_integrator_step_per_update: int = 20,
        fixed_point_tol: float = 1e-8,
        max_fixed_point_iter: int = 100,
        num_thread: int = 4,
    ):
        """
        Args:
            dim_state: Dimension of state vector, here corresponding to number of grid
                points in the discretization of the spatial domain.
            init_state_mean: Initial state distribution mean. Either a scalar or an
                array of shape `(dim_state,)`.
            init_state_std: Initial state distribution standard deviation. Either a 
                scalar or an array of shape `(dim_state,)`.
            state_noise_std: Standard deviation of additive Gaussian noise in state
                update. Either a scalar or an array of shape `(dim_state,)`. Noise in
                each dimension assumed to be independent i.e. a diagonal noise
                covariance. If zero or `None` deterministic dynamics are assumed.
            observation_function: Function computing mean of observation(s) given
                state(s) at a given time index. Defaults to identity function in first
                (states) argument.
            observation_noise_std: Standard deviation of additive Gaussian noise in
                observations. Either a scalar or an array of shape `(dim_observation,)`.
                Noise in each dimension assumed to be independent i.e. a diagonal noise
                covariance.
            delta: Grid spacing parameter for state update.
            force: Forcing constant in state update.
            time_step: Time step for implicit mid-point integrator.
            num_integrator_step_per_update: Number of integrator time-steps between
                successive observations and generated states.
            fixed_point_tol: Convergence tolerance for fixed point iteration.
            max_fixed_point_iter: Maximum number of iterations in fixed-point
                iterative solution of implicit update. `ConvergenceError`
                exception raised if iteration fails to converge within
                specified number.
            num_thread: Number of threads to parallelise integration of dynamics over.
        """
        self.observation_function = observation_function
        if observation_function is None:
            dim_observation = dim_state
        else:
            dim_observation = observation_function(np.zeros(dim_state), 0).shape[-1]
        integrator = Lorenz1996Integrator(
            dim_state=dim_state,
            force=force,
            delta=delta,
            time_step=time_step,
            fixed_point_tol=fixed_point_tol,
            max_fixed_point_iter=max_fixed_point_iter,
            num_thread=num_thread,
        )
        super().__init__(
            integrator=integrator,
            num_integrator_step_per_update=num_integrator_step_per_update,
            dim_state=dim_state,
            dim_observation=dim_observation,
            initial_state_mean=initial_state_mean,
            initial_state_std=initial_state_std,
            state_noise_std=state_noise_std,
            observation_noise_std=observation_noise_std,
        )

    def _observation_mean(self, states, t):
        if self.observation_function is None:
            return states
        else:
            return self.observation_function(states, t)
